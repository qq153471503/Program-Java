/**
 * 控制线程结束方式 一
 * 定义标志  在有些时候 无法停止线程 看未注释代码
 * */
//public class ThreadCommunicaitonDemo4 {
//
//	/**
//	 * @param args
//	 */
//	public static void main(String[] args) {
//		
//		Demo d = new Demo();
//		Thread t1 = new Thread(d);
//		Thread t2 = new Thread(d);
//		t1.start();
//		t2.start();
//		
//		int cnt=0;
//		for(;;){
//			if(cnt++ == 50){
//				d.setFlag(false);
//				break;
//			}
//			System.out.println("main"+cnt);
//		}
//
//		System.out.println("over...");
//	}
//
//}
//
//
//class Demo implements Runnable{
//	
//	private boolean flag = true;
//	public void run() {
//		
//		while(flag) {
//			System.out.println(Thread.currentThread().getName()+"...run");
//		}
//	}
//	
//	public void setFlag(boolean flag) {
//		this.flag = flag;
//	}
//}


/**
 * 线程如果使用到同步  就会进入wait状态，主线程执行完毕之后，
 * 其他线程就会陷入等待状态，并没有停止 可以使用interrupt方法强制唤醒，
 * 使该线程具有cpu的执行资格
 * 
 * 注意事项：强制唤醒之后，记得要在catch中处理 例如本demo
 * */
public class ThreadCommunicaitonDemo4 {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		
		Demo d = new Demo();
		Thread t1 = new Thread(d);
		Thread t2 = new Thread(d);
		t1.start();
		t2.start();
		
		int cnt=0;
		for(;;){
			if(cnt++ == 50){
//				d.setFlag(false);
				t1.interrupt();
				t2.interrupt();
				break;
			}
			System.out.println("main.."+cnt);
		}

		System.out.println("over...");
	}

}


class Demo implements Runnable{
	
	private boolean flag = true;
	
	public synchronized void run() {
		
		while(flag) {
			try{
				this.wait();

			}catch (InterruptedException e) {
				
				//interrupt唤醒之后 在此处继续运行，将flag置为false
				this.flag = false;
				
				System.out.println(Thread.currentThread().getName()+"..."+e);
			}
			
			System.out.println(Thread.currentThread().getName()+"...run++++");
		}
	}
	
	public void setFlag(boolean flag) {
		this.flag = flag;
	}
}

